# 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다. 웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재한다면, 그 문서는 원 서버가 아니라 그 캐시로부터 제공된다.

## 불필요한 데이터 전송

복수의 클라이언트가 자주 쓰이는 서버 페이지 접근시, 서버는 같은 문서를 클라이언트들에게 각각 한 번씩 전송하게 된다. 캐시를 이용하면, 첫 번째 서버 응답은 캐시에 보관된다. 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용될 수 있기 때문에, 서버가 중복해서 트래픽을 주고받는 낭비가 줄어들게 된다.

## 대역폭 병목

캐시는 네트워크 병목을 줄여준다. 클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같다. 만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선할 수 있을 것이다.

## 갑작스런 요청 쇄도(Flash Crowds)

캐싱은 갑작스런 요청 쇄도에 대처하기 위해 중요하다. 트래픽 급증은 네트워크와 웹 서버의 심각한 장애를 야기시킨다. 

## 거리로 인한 지연

모든 네트워크 라우터는 인터넷 트래픽을 지연시킨다. 클라이언트와 서버 사이에 라우터가 많지 않더라도, 빛의 속도 그 자체가 유의미한 지연을 유발한다. 기계실 근처에 캐시를 설치해서 문서가 전송되는 거리를 수천 킬로미터에서 수십 미터로 줄일 수 있다.

## 적중과 부적중

캐시가 세상 모든 문서의 사본을 저장하지는 않는다.

* 캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 대응하는 사본이 있다면 이를 이용해 요청이 처리될 수 있다.
* 캐시 부적중(cache miss): 캐시에 요청이 도착했을 때, 대응하는 사본이 없다면 서버로 전달되기만 한다.

### 재검사(Revalidation)

서버 콘텐츠는 변경될 수 있기 때문에, 캐시는 반드시 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다. 이러한 '신선도 검사'를 HTTP 재검사라 부른다.

캐시는 캐시된 사본의 재검사가 필요할 때, 서버에 작은 재검사 요청을 보낸다. 콘텐츠가 변경되지 않았다면 `304 Not Modified` 응답을 보낸다. 이를 재검사 적중, 느린 적중이라고 부른다.

HTTP는 캐시된 객체를 재확인하기 위한 도구를 제공한다. 서버에 GET 요청시 `If-Modified-Since` 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미이다. 

다음은 `GET If-Modified-Since` 요청이 서버 도착시 일어날 수 있는 세 가지 상황이다.
* 재검사 적중
    * 서버 객체 변경되지 않은 경우
    * `HTTP 304 Not Modified` 응답
* 재검사 부적중
    * 서버 객체가 캐시된 사본과 다른 경우
    * 서버는 콘첸츠 전체와 함께 `HTTP 200 OK` 응답
* 객체 삭제
    * 서버 객체가 삭제된 경우
    * `404 Not Found` 응답
    * 캐시는 사본을 삭제

### 적중률

* 캐시 적중률 또는 문서 적중률
    * 캐시가 요청을 처리하는 비율
    * 0~1 또는 퍼센트로 표현되기도 한다.

### 바이트 적중률

문서들이 모두 같은 크기인 것은 아니기 때문에, 문서 적중률이 모든 것을 말해주지는 않는다.

바이트 단위 전중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다. 이 측정값은 트래픽이 절감된 정도를 포착해낸다. 바이트 단위 적중률 100%는 모든 바이트가 캐시에서 왔으며, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다. 

이러한 적중률은 캐시 성능에 대한 유용한 지표가 된다.

### 적중과 부적중의 구별

HTTP는 클라이언트에게 응답이 캐시 적중이었는지, 서버 접근인지 말해줄 수 있는 방법을 제공하지 않는다.

클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 `Date` 헤더 또는 `Age` 헤더를 이용하는 것이다.

## 캐시 토폴로지

### 개인 전용 캐시

대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시해 놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용한다.

### 공용 프락시 캐시

공용 캐시는 캐시 프락시 서버 또는 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버다. 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 사용자의 입정에서 서버에 접근한다. 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

### 프락시 캐시 계층들

클라이언트 주위에는 작고 저렴한 캐시를 사용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용한다.

캐시 계층이 깊다면 요청은 캐시의 긴 연쇄를 따라가게 될 것이다. 프락시 연쇄가 길어질수록 각 중간 프락시는 현저한 성능 저하가 발생할 것이다.

### 캐시망, 콘텐츠 라우팅, 피어링

몇몇 네트워크 아키텍처는 복잡한 캐시망을 만든다.

캐시망 안에서의 **콘텐츠 라우팅**을 위해 설계된 캐시들은 다음에 나열된 일들을 모두 할 수 있을 것이다.
* URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
* URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
* 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
* 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(Internet transit)dms gjdydgkwl dksgsmsek.

복잡한 캐시망은 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해준다.

## 캐시 처리 단계

### 단계1: 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다. 

### 단계2: 파싱

캐시는 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담는다.

### 단계3: 검색

캐시는 URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사한다. 문서를 로컬에서 가져올 수 없다면, 캐시는 상황이나 설정에 따라서 그것을 서버나 부모 프락시에서 가져오거나 실패를 반환한다.

### 단계4: 신선도 검사

캐시된 사본을 신선도 한계를 넘을 정도로 오래 보유한 경우 신선하지 않은 것으로 간주되며, 캐시는 그 문서를 제공하기 전에 문서에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야 한다.

### 단계5: 응답 생성

캐시된 응답을 서버에서 온 것처럼 보이게 하기 위해 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성한다. 

### 단계6: 전송

응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 돌려준다.

### 단계7: 로깅

대부분의 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다. 각 캐시 트랜잭션이 완료된 후, 캐시는 통계 캐시 적중과 부적중 횟수에 대한 통계를 갱신하고 로그 파일에 요청 종류, URL, 무엇이 일어났는지 알려주는 항목을 추가한다.

## 사본을 신선하게 유지하기

### 문서 만료

HTTP는 `Cache-Control`과 `Expires`라는 특별한 헤더들을 이용해서 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.

캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야 하며, 그렇다면 신선한 사본을 얻어 와야 한다.

### 유효기간과 나이

* `Cache-Control: max-age`: max-age 값은 문서의 최대 나이를 정의한다.
* `Expires`: 절대 유효기간을 명시한다.

### 서버 재검사

캐시된 문서가 만료되었다는 것은, 검사할 시간이 되었음을 뜻한다. 이를 '서버 재검사'라고 부른다.

* 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
* 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구한다.
* '충분히 신선한' 캐시된 사본
* 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
* 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
* 경고 메시지가 부착된 캐시된 사본(부정확하다면)

### 조건부 메서드와의 재검사

HTTP의 조건부 메서드 -> 예를 들어 '조건부 GET'은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 *다른 경우에만* 객체 본문을 보내달라고 하는 것이다.

* `If-Modified-Since: <date>` 헤더: 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다.
* `If-None-Match: <tags>` 헤더: 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그를 제공할 수 있다.

### If-Modified-Since: 날짜 재검사

흔히 'IMS'요청으로 불린다. 서버 응답 헤더의 `Last-Modified` 헤더와 함께 동작한다. 캐시는 캐시된 사본이 마지막으로 수정된 날짜가 담긴 `If-Modified-Since` 헤더를 포함한다.

### If-None-Match: 엔터티 태그 재검사

퍼블리셔가 문서를 변경했을 때, 그는 문서의 엔터티 태그를 새로운 버전으로 표현할 수 있다. 엔터티 태그가 변경되었다면, 캐시는 새 문서의 사본을 얻기(GET) 위해 `If-None-Match` 조건부 헤더를 사용할 수 있다.

## 캐시 제어

### no-cache와 no-store 응답 헤더

* `no-store`: 캐시가 그 응답의 사본을 만드는 것을 금지한다.
* `no-cache`: 로컬 캐시 저장소에 저장될 수 있으나 먼저 서버와 재검사를 하지 않고서는 캩시에서 클라이언트로 제공될 수 없다.
```
Cache-Control: no-store
Cache-Control: no-cache
Pragma: no-cache
```

### Max-Age 응답 헤더

* `max-age`: 문서가 서버로부터 온 이후 흐른 시간, 초로 나타낸다. 
* `s-maxage`: max-age처럼 행동하지만 공유된 캐시에만 적용된다.
```
Cache-Control: max-age=3600
Cache-Control: s-maxage=3600
```

### Expires 응답 헤더

실제 만료 날짜를 명시한다.
```
Expires: Fri, 05 Jul 2002, 05:00:00 GMT
```

### Must-Revalidate 응답 헤더

* `must-revalidate`: 캐시가 만료 정보를 엄격하게 따르게 하기 위한 값으로, 캐시가 객체의 만료된 사본을 서버와의 최초의 재검사 없이 제공해서는 안 됨을 의미한다.
```
Cache-Control: must-revalidate
```

### 휴리스틱 만료

만약 Cache-Control: max-age, Expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나이를 계산할 것이다.

* LM 인자 알고리즘
    * 유명한 휴리스틱 만료 알고리즘의 하나
    * 문서가 최근 변경 일시를 포함하고 있는 경우 사용 가능
    * 캐시된 문서가 마지막으로 변경된 것이 상당히 예전이라면, 아마 안정적인 문서일 것이므로 캐시에 더 오래 보관하고 있어도 안전하다.
    * 캐시된 문서가 최근에 변경되었다면, 아마 자주 변경될 것이므로 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야 한다.
    ```
    $마지막_수정_이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified);
    $서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자);
    ```

### 클라이언트 신선도 제약

| 지시어 | 목적 |
|--------|------|
| Cache-Control: max-stale (= s) | 캐시는 신선하지 않은 문서라도 자유롭게 제공할 수 있다. 만약 s 매개변수가 지정되면, 클라이언트는 만료시간이 s 값만큼 지난 문서도 받아들인다. |
| Cache-Control: min-fresh = s | 클라이언트는 지금으로부터 s초 후까지 신선한 문서만을 받아들인다. |
| Cache-Control: max-age = s | 캐시는 s초보다 오랫동안 캐시된 문서를 반환할 수 없다. |
| Cache-Control: no-cache <br> Pragma: no-cache | 이 클라이언트는 캐시된 리소스를 재검사하기 전에는 받아들이지 않을 것이다. |
| Cache-Control: no-store | 이 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 한다. 민감한 정보가 포함되어 있기 때문이다. |
| Cache-Control: only-if-cached | 클라이언트는 캐시에 들어있는 사본만을 원한다. |

## 자세한 알고리즘

### 나이와 신선도 수명

### 나이 계산

### 완전한 나이 계산 알고리즘

### 신선도 수명 계산

### 완전한 서버 신선도 알고리즘
