# 프락시

웹 프락시 서버는 중개자다. 프락시는 클라이언트와 서버 사이에 위치하여 HTTP 메시지를 정리하는 중개인처럼 동작한다. 

## 웹 중개자

* 웹 프락시 서버
    * 클라이언트의 입장에서 트랜잭션을 수행하는 중개인
    * 클라이언트는 HTTP 서버와 이야기하는 대신, 자신의 입장에서 서버와 대화해주는 프락시와 이야기한다
* HTTP 프락시 서버
    * 웹 서버이기도, 웹 클라이언트이기도 하다
    * HTTP 클라이언트와 HTTP 서버 양쪽 규칙 모두를 주의 깊게 따라야 한다

### 개인 프락시와 공유 프락시

* 공용 프락시
    * 대부분의 프락시는 공용이며 공유된 프락시다
    * 중앙 집중형 프락시를 관리하는 게 비용효율이 높고 쉽다
    * 캐시 프락시 서버 등의 몇몇 프락시 애플리케이션은 프락시 사용자가 많을수록 유리하다(여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문)

* 개인 프락시
    * 흔하지 않지만 꾸준히 사용되고 있다
    * 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 ISP 서비스를 위한 광고를 운영하기 위해 작은 프락시를 사용자의 컴퓨터에서 직접 실행한다

### 프락시 대 게이트웨이

* 프락시: **같은 프로토콜**을 사용하는 둘 이상의 애플리케이션을 연결
* 게이트웨이: **서로 다른 프로토콜**을 사용하는 둘 이상을 연결, 프로토콜 변환기처럼 동작

## 왜 프락시를 사용하는가?

프락시 서버는 보안 개선, 성능 향상, 비용 절약 등의 **실용적이고 유용한 일**을 한다. 또한 모든 HTTP 트래픽을 들여다보고 건드릴 수 있어 부가적인 가치를 주는 서비스를 위하여 **트래픽을 감시하고 수정**할 수 있다.

예) 
* 어린이에게 부적절한 사이트 접근을 막는 필터링 프락시
* 문서 접근 제어자
    * 웹 서버, 웹 리소스에 대한 단일 접근 제어 전략 구현 -> 중앙 프락시 서버에서 접근 제어 설정
* 보안 방화벽
* 웹 캐시
    인기 있는 문서의 로컬 사본 관리를 통해 요청에 대한 빠른 제공
* 대리 프락시(리버스 프락시)
    * 웹 서버인 것처럼 위장
    * 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션
    * 공용 콘탠츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용
    * 서버 가속기라 부른다
    * 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용 가능
* 콘텐츠 라우터
    * 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도
* 트랜스코더
    * 콘텐츠를 클라이언트에 전달하기 전 본문 포맷을 수정할 수 있다
* 익명화 프락시
    * HTTP 메시지에서 신원 식별할 수 있는 특성을 제거함으로써 개인 정보 보호, 익명성 보장에 기여
    * 사용자의 메시지를 다음과 같이 변경함
        * User-Agent 헤더에서 사용자의 컴퓨터, OS 종류 제거
        * 이메일 주소 보호를 위해 From 헤더 제거
        * 어떤 사이트를 거쳐서 방문했는지 알기 어렵도록 Referer 헤더 제거
        * 프로필과 신원 정보 제거를 위해 Cookie 헤더 제거

## 프락시는 어디에 있는가?

### 프락시 서버 배치

사용 목적에 따라 프락시는 어디에든 배치할 수 있다.

* 출구 프락시
    * 로컬 네트워크의 출구에
* 접근 프락시
    * ISP 접근 지점에
* 대리 프락시
    * 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에
* 네트워크 교환 프락시
    * 네트워크 사이의 인터넷 피어링 교환 지점들에

### 프락시 계층

프락시들은 프락시 계층이라고 불리는 연쇄를 구성할 수 있다. 메시지는 최종적으로 원 서버에 도착할 때까지 프락시와 프락시를 거쳐 이동한다.

프락시 계층에서 프락시 서버들은 부모-자식 관계를 갖는다.

* 인바운드 프락시(서버에 가까운 쪽): 부모
* 아웃바운드 프락시(클라이언트에 가까운 쪽): 자식

### 어떻게 프락시가 트래픽을 처리하는가

클라이언트 트래픽이 프락시로 가도록 만드는 방법:

1. 클라이언트 수정
    * 구글 크롬, 마이크로소프트의 브라우저 등 많은 웹 클라이언트들은 수동, 자동 프락시 설정을 지원하여 클라이언트가 프락시 사용하도록 설정되어 있는 경우, 클라이언트는 HTTP 요청을 바로 원 서버가 아닌 프락시로 보낸다.
2. 네트워크 수정
    * 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정
    * 스위칭 장치, 라우팅 장치 필요
    * 인터셉트 프락시라고 부름
3. DNS 이름공간 수정
    * 대리 프락시(웹 서버 앞에 위치하는 프릭사 서버)는 웹 서버의 이름과 IP 주소를 자신이 직접 사용하므로 모든 요청은 서버 대신 대리 프락시로 간다
4. 웹 서버 수정
    * HTTP 리다이렉션 명령을 클라이언트에게 돌려줌으로써 클라이언트의 요청을 프락시로 리다이렉트하도록 설정 가능

## 클라이언트 프락시 설정

### 수동

많은 클라이언트가 프락시를 수동으로 설정할 수 있도록 하고 있다.

### PAC 파일

프락시 자동 설정(PAC) 파일은 프락시 설정에 대한 동적인 해결책이다. 프락시 설정을 상황에 따라 계산해주는 자바스크립트 프로그램이다. 사용하기 위해서 PAC 파일의 URI를 브라우저에 설정해야 한다. 일반적으로 `.pac` 확장자를 가지며 MIME 타입은 `application/x-ns-proxy-autoconfig`이다. 각 PAC 파일은 URI에 접근할 때 사용할 프락시 서버를 계산해주는 `FindProxyForUrl(url, host)`라는 함수를 정의해야 한다.

### WPAD

웹 프락시 자동발견 프로토콜(WPAC)은 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘이다.

## 프락시 요청의 특징

### 프락시 URI는 서버 URI와 다르다

문법은 서로 같지만, 예외가 있다. 클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라진다.

EX) 
* 클라이언트 -> 웹 서버 요청시 (부분 URI)
```
GET /index.html HTTP/1.0
User-Agent: SuperBrowserv1.3
```
단일 서버는 자신의 호스트명과 포트번호를 알고 있으므로, 불필요한 정보 발송을 피하기 위해 부분 URI만 보냈다.

* 클라이언트 -> 프락시 요청시 (완전한 URI)
```
GET http://www.marys-antiques.com/index.html HTTP/1.0
User-Agent: SuperBrowser v1.3
```
프락시는 목적지 서버와 커넥션을 맺어야 하기 때문에, 서버의 이름을 알 필요가 있었다.

### 인터셉트 프락시는 부분 URI를 받는다

* 대리 프락시: 원 서버의 호스트명과 IP주소를 사용하여 원 서버를 대신하는 프락시 서버
* 인터셉트 프락시: 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽을 가로채 캐시된 응답을 돌려주는 등의 일을 하는 프락시 서버. 웹 서버로 보내는 부분 URI를 얻게 된다.

### 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

다목적 프락시 서버는 요청 메시지의 완전한 URI와 부분 URI를 모두 지원해야 한다.
웹 서버 요청의 경우 가상 Host 헤더를 사용해야 한다.
* 완전한 URI가 주어졌다면 프락시는 그것을 사용해야 한다.
* 부분 URI + Host 헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아내야 한다.
* 부분 URI가 있고 Host 헤더가 없다면, 
  - 대리 프락시인 경우, 프락시에 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있다.
  - 인터셉트 프락시인 경우, 원 IP 주소와 포트번호를 사용할 수 있도록 해두었다면, 사용할 수 있다.
  - 모두 실패했다면 에러 메시지를 반환해야 한다.

### 전송 중 URI 변경

프락시 서버는 요청 URI의 변경에 매우 신경을 써야 한다. 사소한 URI 변경이라도 다운스트림 서버와 상호운용성 문제를 일으킬 수 있다.

### URI 클라이언트 자동확장과 호스트명 분석

호스트가 발견되지 않는 다면, 많은 브라우저들은 사용자가 호스트명의 짧은 약어를 타이핑한 것으로 보고 자동화된 호스트명의 '확장'을 제공하고자 몇 가지 시도를 한다.
* 웹 사이트 이름의 가운데 부분만 입력한 경우: 'www.' 접두사를 붙이고, '.com' 접미사를 붙인다.
* 해석할 수 없는 URI를 서드파티 사이트로 넘기기도 하는데, 이는 오타 교정을 시도하고 사용자가 의도했을 URI를 제시해준다.
* DNS는 사용자가 호스트명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정되어 있다. EX) 'oreilly.com'이라는 도메인에 있을 때 'host7'을 입력하면, 그 도메인의 DNS는 자동으로 'host7.oreilly.com'를 찾아본다.

### 프락시 없는 URI 분석

* 프락시 없는 브라우저 호스트명 자동확장 예시:
1. 'oreilly'를 브라우저의 URI창에 입력한다.
2. 브라우저는 'oreilly'를 호스트명으로 사용, 기본 스킴을 'http://'로, 기본 포트를 '80'으로, 기본 경로를 '/'로 간주한다.
3. 브라우저는 호스트 'oreilly'를 찾아본다. 실패한다.
4. 브라우저는 호스트명을 자동으로 확장한 후 DNS에 'www.oreilly.com'의 주소 분해(resolve)를 요청한다. 성공한다.
5. 브라우저는 www.oreilly.com으로 연결하는 데 성공한다.

### 명시적인 프락시를 사용할 때의 URI 분석

명시적인 프락시가 있는 경우 부분 호스트명을 자동확장하지 않는다.

## 메시지 추적

웹 요청이 둘 이상의 프락시를 지나는 것은 드문 일이 아니다. 

EX) 회사 보안과 비용 절감을 위한 캐시 프락시 서버 사용, ISP들이 성능 개선과 기능 구현을 위해 프락시 캐시 사용, 성능상의 이유로 대리 캐시 저장고에 콘텐츠 복제 등.

### Via 헤더

Via 헤더 필드는
* 메시지가 지나는 각 중간 노드(프락시, 게이트웨이)의 정보를 나열한다. 
* 메시지의 전달을 추적하고, 메시지 루프를 진단하고, 요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다.
* 네트워크의 라우팅 루프를 탐지하기 위해 사용할 수 있다.
* 응답의 Via 헤더는 거의 언제나 요청의 Via 헤더와 반대다.
* 프로토콜 변환을 기록하므로 HTTP 애플리케이션은 프락시 연쇄에서 프로토콜 능력과 변환이 있었는지를 알아챌 수 있다.

### TRACE 메서드

프락시 서버는 메시지가 전달될 때 메시지를 바꿀 수 있다. 프락시 네트워크를 쉽게 진단하기 위해, 홉에서 홉으로 전달될 때마다 메시지 내용이 어떻게 변하는지 편리하게 관찰할 방법이 필요하다.

HTTP/1.1의 *TRACE* 메서드는 어떤 프락시를 지나가고 어떻게 각 프락시가 요청 메시지를 수정하는지 관찰/추적할 수 있다. 프락시 흐름을 디버깅하는데 매우 유용하다. TRACE 요청이 목적지 서버에 도착했을 때, 서버는 전체 요청 메시지를 HTTP 응답 메시지의 본문에 포함시켜 송신자에게 그대로 돌려보낸다. 

## 프락시 인증

프락시는 접근 제어 장치로서 제공될 수 있다.

* 제한된 콘텐츠에 대한 요청이 프락시 서버에 도착시, 접근 자격을 요구하는 `407 Proxy Authorization Required` 상태코드를, 어떻게 자격을 제출할 수 있는지 설명해주는 `Proxy-Authenticate` 헤더 필드와 함께 반환할 수 있다.
* 클라이언트는 407 응답을 받으면, 요구되는 자격을 수집한다.
* 클라이언트는 요구되는 자격을 `Proxy-Authenticate` 헤더 필드에 담아서 요청을 다시 보낸다.
* 자격이 유효하다면, 프락시는 원 요청을 연쇄를 따라 통과시킨다. 유효하지 않다면 407 응답을 보낸다.

## 프락시 상호운용성

### 지원하지 않는 헤더와 메서드 다루기

이해할 수 없는 헤더 필드는 반드시 그대로 전달해여ㅑ 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우 상대적인 순서를 반드시 유지해야 한다. 프락시가 어떤 메서드와 친숙하지 않다면, 그 메시지를 다음 홉으로 전달항려 시도해야 한다.

### OPTIONS: 어떤 기능을 지원하는지 알아보기

HTTP OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트(또는 프락시)가 알아볼 수 있게 해준다.

### Allow 헤더

Allow 엔터티 헤더 필드는 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다. 

EX)
```
Allow: GET, HEAD, PUT
```
