# 보안 HTTP

## HTTP를 안전하게 만들기

보다 중요한 트랜잭션을 위해서는 HTTP와 디지털 암호화 기술을 결합해야 한다.

HTTP의 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 한다. 사회와 정부의 요구사항에도 맞아야 한다. 다음을 제공해줄 수 있는 HTTP 보안 기술이 필요하다.

* 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
* 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
* 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
* 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
* 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
* 편재성(Ubiquity) - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
* 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
* 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
* 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### HTTPS

## 디지털 암호학

* 암호 - 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
* 키 - 암호의 동작을 변경하는 숫자로 된 매개변수
* 대칭키 암호 체계 - 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
* 비대칭키 암호 체계 - 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
* 공개키 암호법 - 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
* 디지털 서명 - 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
* 디지털 인증서 - 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 암호(cipher)

암호법은 암호라 불리는 비밀 코드에 기반한다. 암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.
* 평문: 인코딩되기 전의 원본 메시지

### 암호 기계

암호를 깨뜨리기 어렵게 하기 위해, 단순히 회전을 하는 대신 글자들을 대체하고, 그 순서를 바꾸었으며, 메시지를 자르고 토막내었다. 

### 키가 있는 암호

대부분의 기계들에는 암호의 동작방식을 변경할 수 있는 큰 숫자로 된 다른 값을 설정할 수 있는 다이얼이 달려있다. 

이러한 암호 매개변수를 키라고 부른다. 디코딩 과정을 바르게 동작시키려면 올바른 키를 암호 기계에 입력할 필요가 있다. 암호 키는 하나의 암호 기계를 여러 가상 암호 기계의 집합처럼 만들어준다. 이 가상 암호 기계들은 서로 다른 키 값을 갖고 있기 때문에 제각각 다르게 동작한다.

## 대칭키 암호법

* 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같다.
* 발송자와 수신자 모두 통신을 위해 비밀키 k를 똑같이 공유할 필요가 있다. 발송자는 공유된 비밀 키를 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용한다. 수신자는 암호문을 받은 뒤 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독 함수를 적용한다.
* DES, Triple-DES, RC2, RC4 등이 있다.

### 공유키 발급하기

대칭키 암호의 단점 중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.

A, B, C가 각각 J와의 대화를 원하는 경우, A, B, C는 각각 J와의 비밀 키를 발급해야 한다. 만약 N개의 노드가 있고, 각 노드가 상대 N-1과 은밀하게 대화를 나누어야 한다면, 대략 총 N^2개의 비밀 키가 필요하다. 

## 공개키 암호법

공개키 암호 방식은 두 개의 비대칭 키를 사용한다. 하나는 호스트의 메시지를 인코딩하기 위한 것이고, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다. 인코딩 키는 모두를 위해 공개되어 있다. 하지만 호스트만이 개인 디코딩 키를 알고 있다.

메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에, 메시지를 디코딩하는 능력은 소유자에게만 부여한다. 

### RSA

공개키 비대칭 암호의 과제는 공개키, 가로채서 얻은 암호문의 일부, 메시지와 그것을 암호화한 암호문을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜 주어야 한다.

이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 RSA 알고리즘이다.

## 디지털 서명

### 서명은 암호 체크섬이다

디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬이다. 이들은 두 가지 이점을 가진다.

* 서명은 메시지를 작성한 저자가 누군지 알려준다. 저자는 저자의 극비 개인 키를 갖고 있기 때문에 오직 저자만이 이 체크섬을 계산할 수 있다.
* 서명은 메시지 위조를 방지한다. 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞기 않게 될 것이다. 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인 키는 오직 소유자만이 알고 있기 때문에 저자의 개인 키는 일종의 '지문'처럼 사용된다.

## 디지털 인증서

### 인증서의 내부

디지털 인능서에는 공식적으로 '인증 기관'에 의해 디지털 서명된 정보의 집합이 담겨있다. 기본적인 디지털 인증서는 보통 다음과 같이 인쇄된 ID에도 흔히 들어가게 되는 기본적인 것들을 담고 있다.

* 대상의 이름(사람, 서버, 조직 등)
* 유효 기간
* 인증서 발급자(누가 이 인증서를 보증하는가)
* 인증서 발급자의 디지털 서명

### 서버 인증을 위해 인증서 사용하기

가뇬바다 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패한다. 서버 인증서는 다음을 포함한 많은 필드를 갖고 있다.

* 웹 사이트의 이름과 호스트명
* 웹 사이트의 공개키
* 서명 기관의 이름
* 서명 기관의 서명

브라우저가 인증서를 받으면, 서명 기관을 검사한다. 그 기관이 신뢰할 만한 서명 기관이라면 브라우저는 그 공개키를 이미 알고 있을 것이며, 브라우저는 그 서명을 검증할 수 있다. 

## HTTPS의 세부사항

### HTTPS 개요

HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다. 암호화되지 않은 HTTP 메시지를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.

오늘날, HTTPS의 보안 계층은 SSL과 그것의 현대적 대체품인 TLS로 구현되었다. 우리는 SSL과 TLS 모두를 의미하는 단어로 'SSL'을 사용하는 관행을 따를 것이다.

### HTTPS 스킴

오늘날 보안 HTTP는 선택적이다.

보안이 없는 일반적인 HTTP는 URL의 스킴 접두사는 다음과 같이 http이다.
```
http://www.joes-hardware.com/index.html
```

보안이 되는 HTTPS 프로토콜에서 URL의 스킴 접두사는 다음과 같이 https이다.
```
https://cajun-shop.securesites.com/Merchant2/merchant.mv?Store_Code=AGCGS
```

클라이언트는 웹 리소스에 대한 트랜잭션 수행을 요청받으면 URL의 스킴을 검사한다.
* URL이 http 스킴을 갖고 있다면, 클라이언트는 서버에 80번 포트로 연결하고 평범한 HTTP 명령을 전송한다.
* URL이 https 스킴을 갖고 있다면, 클라이언트는 서버에 443번 포트로 연결하고 서버와 바이너리 포맷으로 된 몇몇 SSL 보안 매개변수를 교환하면서 '핸드셰이크'를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

### 보안 전송 셋업

HTTPS에서 클라이언트는 먼저 웹 서버의 **443 포트**로 연결한다. 일단 **TCP 연결**이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 **SSL 계층을 초기화**한다. **핸드셰이크**가 완료되면 SSL 초기화는 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있다. 이 메시지는 **TCP로 보내지기 전에 암호화**된다.

### SSL 핸드셰이크

암호화된 HTTP 메시지를 보낼 수 있게 되기 전에, 클라이언트와 서버는 SSL 핸드셰이크를 할 필요가 있다. 핸드셰이크에서는 다음과 같은 일이 일어난다.

* 프로토콜 버전 번호 교환
* 양쪽이 알고 있는 암호 선택
* 양쪽의 신원을 인증
* 채널을 암호화하기 위한 임시 세션 키 생성

### 서버 인증서

SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다. 그러나 오늘날 클라이언트 인증서는 웹 브라우징에선 흔히 쓰이지 않는다. 대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다. 웹 서버는 클라이언트 인증서를 요구할 수 있지만, 실제로는 좀처럼 일어나지 않는 일이다.

한편 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다. 서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그 외 정보를 보여주는 X.509 v3에서 파생된 인증서이다. 사용자와 사용자의 클라이언트 소프트웨어는 모든 것이 믿을 만한 것인지 확인하기 위해 인증서를 검증할 수 있다.

### 사이트 잍증서 검사

* 날짜 검사
* 서명자 신뢰도 검사
* 서명 검사
* 사이트 신원 검사

## 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜이다. 몇 가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 상용 또는 오픈 소스 라이브러리들이 존재한다.

### OpenSSL

OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다.