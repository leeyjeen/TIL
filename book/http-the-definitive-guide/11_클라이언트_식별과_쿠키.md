# 클라이언트 식별과 쿠키

## 개별 접촉

HTTP는 익명, 상태가 없고 요청과 응답으로 통신하는 프로토콜이다.

서버는 클라이언트가 보낸 요청을 처리 후 응답을 클라이언트에게 전송한다. 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다. 

* 개별 인사
* 사용자 맞춤 추천
* 저장된 사용자 정보
* 세션 추적
    * HTTP 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적이다. 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남긴다. (ex. 장바구니) 이렇게 상태를 유지하기 위해 사이트는 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.

## HTTP 헤더

* 사용자에 대한 정보를 전달하는 HTTP 헤더

    헤더 이름 | 헤더 타입 | 설명
    --- | --- | --- 
    From | 요청 | 사용자의 이메일 주소 
    User-Agent | 요청 | 사용자의 브라우저
    Referer | 요청 | 사용자가 현재 링크를 타고 온 근원 페이지
    Authorization | 요청 | 사용자 이름과 비밀번호
    Client-ip | 확장(요청) | 클라이언트의 IP 주소
    X-Forwarded-For | 확장(요청) | 클라이언트의 IP 주소
    Cookie | 확장(요청) | 서버가 생성한 ID 라벨
    
## 클라이언트 IP 주소

클라이언트 IP 주소로 사용자를 식별하는 방식은 다음과 같은 약점을 갖는다.
* 클라이언트 IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다. 만약 여러 사용자가 같은 컴퓨터를 사용한다면 그들을 식별할 수 없다.
* 많은 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP 주소를 할당한다. 로그인한 시간에 따라 사용자는 매번 다른 주소를 받는다.
* 사용자가 네트워크 주소 변환(Network Address Translation, NAT) 방화벽을 통해 인터넷을 사용한다. NAT 장비들은 클라이언트의 실제 IP 주소를 방화벽 뒤로 숨기고 클라이언트의 실제 IP 주소를 내부에서 사용하는 하나의 방화벽 IP주소로 변환한다.
* 보통 HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트 IP 주소 대신 프락시 서버의 IP 주소를 본다. 

## 사용자 로그인

HTTP는 WWW-Authenticate와 Authorization 헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 체계를 가지고 있다.

## 뚱뚱한 URL

어떤 웹 사이트는 사용자의 URL마다 버전을 기수랗여 사용자를 식별하고 추적하였다. URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다. 사용자가 그 사이트를 돌아다니면, 웹 서버는 URL에 있는 상태 정보를 유지하는 하이퍼링크를 동적으로 생성한다. 이렇게 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 부른다. 

웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 또는 '방문'으로 묶는 용도로 이를 사용할 수 있다. 사용자가 사이트 처음 방문시 unique한 ID가 생성되고 서버가 인식할 수 있는 방식으로 URL에 추가되며 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트 시킨다.

그러나 뚱뚱한 URL은 다음과 같은 문제점을 갖는다.

* 못생긴 URL
* 공유하지 못하는 URL
* 캐시를 사용할 수 없음
* 서버 부하 가중
* 이탈
* 세션 간 지속성의 부재

## 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중 현재까지 가장 널리 사용하는 방식이다.

### 쿠키의 타입

* 세션 쿠키(Session Cookie)
   * 사용자가 사이트를 탐색할 때, 관련 설정과 선호 사항들을 저장하는 임시 쿠키
   * 사용자가 브라우저를 닫으면 삭제된다
* 지속 쿠키(Persistent Cookie)
   * 삭제되지 않고 더 길게 유지될 수 있다
   * 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다
   * 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다

### 쿠키는 어떻게 동작하는가

사용자가 웹 사이트에 처음 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다. 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다. 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 또는 Set-Cookie2(확장 헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달된다.

EX)
```
Cookie: name="Brian Totty"; phone="555-1212"
```

브라우저는 서버로 온 Set-Cookie 또는 Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터베이스에 저장한다. 사용자가 같은 사이트를 재방문하면 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청 헤더에 기술해 전송한다.

### 쿠키 상자: 클라이언트 측 상태

쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다. 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 '클라이언트 측 상태'라고 한다. 이를 'HTTP 상태 관리 체계'라고 한다.

### 사이트마다 다른 쿠키들

브라우저는 보통 각 사이트에 2개 또는 3개의 쿠키만을 보낸다. 이유는 다음과 같다.

* 쿠키를 모두 전달하면 성능이 크게 저하된다.
* 쿠키들 대부분은 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에, 대부분 사이트에서는 인식하지 않는 무의미한 값이다.
* 모든 사이트에 쿠키 전체를 전달하는 것은, 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에서 가져갈 수 있어서 잠재적인 개인정보 문제를 일으킬 것이다.

보통 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다. 

### 쿠키와 세션 추적

쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다. Amazon.com의 예시를 살펴보자. http://www.amazon.com을 브라우저에 입력하면, 일련의 리다이렉트, URL 리라이트, 쿠키 설정을 통해 서버가 식별 정보를 첨부하기 위한 연속적인 트랜잭션을 시작한다.

* Amazon.com 사이트는 세션 쿠키를 이용해서 사용자를 추적한다.
1. 브라우저가 Amazon.com의 루트 페이지를 처음 요청한다.
2. 서버는 클라이언트를 전자상거래 소프트웨어 URL로 리다이렉트 시킨다.
3. 클라이언트는 리다이렉트 URL로 요청 보낸다.
4. 서버는 응답에 두 개의 세션 쿠키를 기술하고 사용자를 다른 URL로 리다이렉트시키며, 클라이언트는 다시 이 쿠키들을 첨부하여 요청을 보낸다. 새로운 URL은 자체에 어떤 상태 정보를 가지고 있으므로 뚱뚱한 URL이라고 할 수 있다. 만약 클라이언트가 쿠키를 사용하지 않게 설정되어 있다면, 사용자가 Amazon.com에서 생성한 뚱뚱한 URL을 따라 리다이렉트 하면서도 사이트를 떠나지 않는 한, 기본 식별 절차는 계속 진행된다.
5. 클라이언트는 새로운 URL을 요청을 앞서 받은 두 개의 쿠키와 함께 보낸다.
6. 서버는 home.html 페이지로 리다이렉트시키고 쿠키 두 개를 더 첨부한다.
7. 클라이언트는 home.html 페이지를 가져오고 총 네 개의 쿠키를 전달한다.
8. 서버는 콘텐츠를 보낸다.

### 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 것은 주의해야 한다. 이전 사용자의 쿠키가 다른 사용자에게 할당되거나 누군가의 개인 정보가 다른 이에게 노출되는 경우가 발생할 수 있다.
캐시를 다루는 기본 원칙은 다음과 같다.
* 캐시되지 말아야 할 문서가 있다면 표시하라
* Set-Cookie 헤더를 캐시 하는 것에 유의하라
* Cookie 헤더를 가지고 있는 요청을 주의하라
