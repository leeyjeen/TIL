# 다이제스트 인증

다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발되었다.

## 다이제스트 인증의 개선점

다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또 다른 HTTP 인증 프로토콜이다.

* 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
* 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
* 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
* 몇몇 잘 알려진 형태의 공격을 막는다.

다이제스트 인증이 가능한 가장 안전한 프로토콜은 아니다. 안전한 HTTP 트랜잭션을 위한 많은 요구사항을 만족하지 못한다. 그러한 요구사항들에는 전송 계층 보안(TLS)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜이다.

그러나 기본 인증을 대체하기 위해 설계된 다이제스트 인증은 기본 인증보다 훨씬 강력하다. 다이제스트 인증은 다른 인터넷 서비스를 위해 제안된 많은 인기 있는 보안 체계들(EX: LDAP, POP, IMAP을 위해 제안된 CRAM-MD5)보다 더 강력하다.

### 비밀번호를 안전하게 지키기 위해 요약 사용하기

다이제스트 인증은 "절대로 비밀번호를 네트워크를 통해 보내지 않는다". 비밀번호 대신 클라이언트는 비밀번호를 비가역적으로 뒤섞은 '지문(fingerprints)', '요약(digest)'을 보낸다. 클라이언트와 서버는 둘 다 비밀번호를 알고 있으므로, 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다. 요약만 주어진 상황에서, 악의적으로 접근하여 원래 비밀번호를 알아내기는 어렵다.

* 다이제스트 인증의 동작 과정
  * 클라이언트가 보호된 문서를 요구한다.
  * 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하는 것을 거부한다. 서버는 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구한다
  * 클라이언트는 비밀번호의 요약을 전달하여 자신이 비밀번호를 알고 있음을 증명한다. 서버는 모든 사용자의 비밀번호를 알고 있으므로, 클라이언트가 제공한 요약과 서버가 스스로 계산한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인할 수 있다.
  * 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교한다. 이 요약 함수는 매우 긴 자릿수의 숫자를 만들어낼 수 있도록 되어 있기 때문에 사실상 찍어서 맞추는 것은 불가능하다. 서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공된다. 이 모든 과정에서 비밀번호는 결코 네트워크를 통해 전송되지 않는다.

### 단방향 요약

요약은 '정보 본문의 압축'이다. 단방향 함수로 동작하고, 일밥ㄴ적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환한다. 대표 요약 함수 중 하나인 **MD5**는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다.

128비트 = 2^128 가지의 서로 다른 압축이 만들어질 수 있다.

만약 비밀번호를 모르는 경우, 요약을 추측하기 위해 끔찍하게 많은 시간을 소모하게 될 것이며, 마찬가지로, 요약을 갖고 있다면 거의 무한개의 입력값들 중 그 요약을 생성하는 값을 찾기 위해 많은 시간을 소모하게 될 것이다.

요약 함수는 보통 **암호 체크섬**(cryptographic checksum)으로 불리며, **단방향 해시 함수**이거나 **지문 함수**(fingerprint function)이다.

### 재전송 방지를 위한 난스(nonce) 사용

불행히도, 요약을 가로채서 서버로 몇 번이고 재전송할 수 있기 때문에 안전하지 않다. 요약은 비밀번호 자체와 다름없다.

이런 재전송 공격을 방지하기 위해 서버는 클라이언트에게 난스라고 불리는 특별하고 자주 바뀌는 증표를 건네준다. 난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어준다. 이것은 재전송 공격을 막아주는데, 왜냐하면 저장된 비밀번호 요약은 특정 난스 값에 대해서만 유효하고, 비밀번호 없이 공격자가 올바른 요약을 계산하는 것은 가능하지 않기 때문이다.

다이제스트 인증은 난스를 사용할 것을 요구한다. 난스는 `WWW-Authenticate` 인증요구에 담겨서 서버에서 클라이언트로 넘겨진다.

### 다이제스트 인증 핸드셰이크

HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는, 강화된 버전의 인증이다.

* 서버는 난스 값을 계산한다. 서버는 난스를 `WWW-Authenticate` 인증요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.
* 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다. 클라이언트는 `Authorization` 메시지에 요약을 담아 서버에게 돌려준다.
* 서버는 요약, 선택한 알고리즘, 그 외 보조 데이터들을 받고, 클라이언트가 했던 그대로 요약을 계산한다. 서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다. 만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면, 클라이언트 요약이 만들어진다. 또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.

## 요약 계산

### 요약 알고리즘 입력 데이터

요약은 다음 세 요소로 계산된다.

* 단방향 해시 함수 `H(d)`와 요약 함수 `KD(s,d)` (s = secret, d = data)
* 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리. A1이라 부른다.
* 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리. A2라 부른다.

A1, A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

### H(d)와 KD(s,d) 알고리즘

다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다. RFC2617에서 제안된 두 알고리즘은 MD5와 MD5-sess이며, 알고리즘이 정해지지 않은 경우 MD5가 기본값이다.

H 함수는 데이터의 MD5를 계산하고, KD 요약 함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산한다.

```
H(<데이터>) = MD5(<데이터>)
KD(<비밀>,<데이터>) = H(연결(<비밀>:<데이터>))
```

### 보안 관련 데이터 (A1)

* 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보
* 메시지 자체가 아닌 비밀 정보와만 관련되어 있다.
* 요약을 계산하기 위해 사용된다.
* MD5, MD5-sess 두 가지 방법으로 계산할 수 있다.

### 메시지 관련 데이터 (A2)

* URL, 요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보
* 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.
* 요약을 계산하기 위해 사용된다.
* 두 가지 사용법
  1. HTTP 요청 메서드와 URL만 포함한다. 기본값이기도 한 qop="auth"일 때 사용된다.
  2. 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가한다. qop="auth-int"일 때 사용된다.

### 요약 알고리즘 전반



### 다이제스트 인증 세션

### 사전(preemptive) 인가

### 난스 선택

### 상호 인증

## 보호 수준(Quality of Protection) 향상

### 메시지 무결성 보호

### 다이제스트 인증 헤더

## 실제 상황에 대한 고려

### 다중 인증요구

### 오류 처리

### 보호 공간(Protection Space)

### URI 다시 쓰기

### 캐시

## 보안에 대한 고려사항

### 헤더 부당 변경

### 재전송 공격

### 다중 인증 메커니즘

### 사전(dictionary) 공격

### 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)

### 선택 평문 공격

### 비밀번호 저장


