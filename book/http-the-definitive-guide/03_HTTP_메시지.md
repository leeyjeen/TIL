# HTTP 메시지

## 메시지의 흐름

**HTTP 메시지**는 *HTTP 애플리케이션 간에 주고받은 데이터의 블록들*이다. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.

### 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTTP는 **인바운드**와 **아웃바운드**라는 용어를 **트랜잭션 방향**을 표현하기 위해 사용한다.

- **인바운드**로 이동하는 것
    - 메시지가 원 **서버로** 향하는 것
- **아웃바운드**로 이동하는 것
    - 모든 처리가 끝난 뒤에 메시지가 **사용자 에이전트로** 돌아오는 것

### 다운스트림으로 흐르는 메시지

HTTP 메시지는 강물과 같이 흐른다. 모든 메시지는 다운스트림으로 흐른다. 메시지의 발송자는 수신자의 업스트림이다. 

## 메시지의 각 부분

각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다. 시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.

예)

- 시작줄

    ```bash
    HTTP/1.0 200 OK
    ```

- 헤더

    ```bash
    Content-type: text
    Content-length: 19
    (빈 줄)
    ```

- 본문

    ```bash
    Hi ~ I'm a message !
    ```

### 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다. 요청 메시지는 웹 서버에 어떤 동작을 요구한다. 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다. 요청과 응답 모두 기본적으로 구조가 같다.

- 요청 메시지

    ```bash
    <메서드> <요청 URL> <버전>
    <헤더>

    <엔터티 본문>
    ```

- 응답 메시지

    ```bash
    <버전> <상태코드> <사유 구절>
    <헤더>

    <엔터티 본문>
    ```

각 부분에 대한 설명은 다음과 같다.

- 메서드
    - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
    - 'GET', 'HEAD', 'POST' 등의 한 단어로 되어 있다
- 요청 URL
    - 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소
- 버전
    - 메시지에서 사요 중인 HTTP의 버전
    - 형식: `HTTP/<메이저>.<마이너>`
- 상태 코드
    - 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자
- 사유 구절
    - 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
    - 사람에게 읽히기 위한 목적으로만 존재
- 헤더들
    - 이름, 콜론(:), 선택적인 공백, 값, CLRF가 순서대로 나타나는 0개 이상의 헤더들
    - 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시
- 엔터티 본문
    - 임의의 데이터 블록을 포함

### 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.

- 요청줄
    - **메서드**: 서버에서 어떤 동작이 일어나야 하는지 설명
    - **요청 URL**: 동작에 대한 대상을 지칭
    - **HTTP 버전**: 클라이언트가 어떤 HTTP버전으로 말하고 있는지 서버에게 알려줌
    - 모든 필드는 공백으로 구분
- 응답줄
    - **HTTP 버전**: 응답 메시지에서 쓰인 HTTP의 버전
    - **상태 코드**: 숫자로 되어 있음
    - **사유 구절**: 수행 상태에 대해 설명해주는 텍스트
    - 모든 필드는 공백으로 구분
- 메서드
    - GET
        - 서버에서 어떤 문서를 가져온다
    - HEAD
        - 서버에서 어떤 문서에 대해 헤더만 가져온다
    - POST
        - 서버가 처리해야 할 데이터를 보낸다
        - 메시지 본문 포함
    - PUT
        - 서버에 요청 메시지의 본문을 저장한다
        - 메시지 본문 포함
    - TRACE
        - 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다
    - OPTIONS
        - 서버가 어떤 메서드를 수행할 수 있는지 확인한다
    - DELETE
        - 서버에서 문서를 제거한다
    - 확장 메서드
        - HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 특정 서버만의 추가 메서드를 구현할 수 있다
- 상태 코드
    - 클라이언트에게 무엇이 일어났는지 말해준다
    - 응답의 시작줄에 위치한다
    - 세 자리 숫자로 된 코드값을 기준으로 분류된다

        | 전체범위 | 정의된 범위 | 분류 |
        |--------|------|------|
        | 100-199 | 100-101 | 정보 |
        | 200-299 | 200-206 | 성공 |
        | 300-399 | 300-305 | 리다이렉션 |
        | 400-499 | 400-415 | 클라이언트 에러 |
        | 500-599 | 500-505 | 서버 에러 |

    - 많이 쓰이는 상태 코드

        | 상태 코드 | 사유 구절 | 의미 |
        |--------|------|------|
        | 200 | OK | 성공. 요청한 모든 데이터는 응답 본문에 들어있다 |
        | 401 | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다 |
        | 404 | Not Found | 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다 |

- 사유 구절
    - 응답 시작줄의 마지막 구성요소
    - 상태 코드에 대한 글로 된 설명 제공
- 버전 번호
    - HTTP/x.y 형식
    - 요청과 응답 메시지 양쪽 모두에 기술
    - HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단

### 헤더

시작줄 다음에는 0~여러 개의 HTTP 헤더가 온다.

기본적으로 이름/값 쌍의 목록이다.

- 헤더 분류
    - 일반 헤더
        - 요청과 응답 양쪽에 모두 나타날 수 있음
    - 요청 헤더
        - 요청에 대한 부가 정보 제공
    - 응답 헤더
        - 응답에 대한 부가 정보 제공
    - Entity 헤더
        - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
    - 확장 헤더
        - 명세에 정의되지 않은 새로운 헤더
- 문법
    - 이름, 쉼표, 공백(옵션), 필드 값, CRLF가 순서대로 온다.
- 예시

    | 헤더의 예 | 설명 |
    |--------|------|
    | Date: Tue. 3 Oct 1997 02:16:03 GMT | 서버가 응답을 만들어 낸 시각 |
    | Content-length: 15040 | 15,040바이트의 데이터를 포함한 엔터티 본문 |
    | Content-type: image/gif | 엔터티 본문은 GIF 이미지다 |
    | Accept: image(gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG 이미지와 HTML을 받아들일 수 있다 |

- 헤더를 여러 줄로 나누기
    - 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자가 와야 한다

### 엔터티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔터티 본문이다. 이는 HTTP가 수송하도록 설계된 것들이다.

HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

### 버전 0.9 메시지

HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다.

- 요청
    - 메서드와 요청URL로 구성
- 응답
    - 엔터티로만 구성

## 메서드

모든 서버가 모든 메서드를 구현하지는 않는다. HTTP 버전 1.1과 호환되고자 한다면, 서버는 자신의 리소스에 대해 GET과 HEAD 메서드만을 구현하는 것으로 충분하다.

### 안전한 메서드(Safe Method)

GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.

안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

### GET

서버에게 리소스를 달라고 요청하기 위해 쓰인다.

HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.

### HEAD

HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 엔터티 본문은 결코 반환되지 않는다. 

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야 한다.

HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.

### PUT

PUT 메서드는 서버에 문서를 쓴다.

서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체한다.

콘텐츠를 변경할 수 있게 해준다.

### POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다.

서버는 데이터를 모아서 필요로 하는 곳(예: 그 데이터를 처리할 서버 게이트웨이 프로그램)에 보낸다. 

### TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다. TRACE 메서드는 *클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다*.

TRACE 요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작한다. 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.

TRACE 요청은 엔터티 본문을 보낼 수 없다. 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.

### OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버에게 *특정 리소스에 대해 어떤 메서드가 지원되는지* 물어볼 수 있다.

### DELETE

DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

### 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있다. 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.

## 상태 코드

### 100-199: 정보성 상태 코드

정보성 상태 코드는 HTTP/1.1에서 도입되었다. 

| 상태 코드 | 사유 구절 | 의미 |
|--------|------|------|
| 100 | Continue | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속이어서 보내야함을 의미한다. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다. |
| 101 | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다. |

### 200-299: 성공 상태 코드

| 상태 코드 | 사유 구절 | 의미 |
|--------|------|------|
| 200 | OK | 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다. |
| 201 | Created | 서버 개체를 생성하라는 요청(예: PUT)을 위한 것. 응답은, 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다. |
| 202 | Accepted | 요청은 받아들여졌으나, 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. |
| 203 | Non-Authoritative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. |
| 204 | No Content | 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용한다. |
| 205 | Reset Content | 주로 브라우저를 위해 사용되는 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다. |
| 206 | Partial Content | 부분 혹은 범위 요청이 성공했다. |

### 300-399: 리다이렉션 상태 코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 *리소스에 대해 다른 위치를 사용하라*고 말해주거나 그 *리소스의 내용 대신 다른 대안 응답을 제공*한다.

리다이렉션 상태 코드 중 일부는 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.

| 상태 코드 | 사유 구절 | 의미 |
|--------|------|------|
| 300 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청할 경우, 그 리소스의 목록과 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다. |
| 301 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다. |
| 302 | Found | 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다. |
| 303 | See Other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰인다. 사용 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다. |
| 304 | Not Modified | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. |
| 305 | Use Proxy | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해서 사용한다. 프락시의 위치는 Location 헤더를 통해 주어진다. |
| 306 | 사용되지 않음 | 현재 사용되지 않는다. |
| 307 | Temporary Redirect | 301 상태 코드와 비슷하다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. ㅣㅇ후의 요청에서는 원래 URL을 사용해야 한다. |

### 400-499: 클라이언트 에러 상태 코드

| 상태 코드 | 사유 구절 | 의미 |
|--------|------|------|
| 400 | Bad Request | 클라이언트가 잘못된 요청을 보냈다고 알려준다. |
| 401 | Unauthorized | 리소스를 열기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다. |
| 402 | Payment Required | 쓰이지 않지만 미래를 위해 준비해 둔 상태코드 |
| 403 | Forbidden | 요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다. 만약 서버가 왜 요청이 거부되었는지 알려주고자 한다면, 서버는 그 이유를 설명하는 엔터티 본문을 포함시킬 수 있다. 이는 보통 서버가 거절의 이유를 숨기고 싶을 때 사용한다. |
| 404 | Not Found |  서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다. |
| 405 | Method Not Allowed | 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용한다. |요청한 리소스에 대해 어떤 메서드가 사용 가능한지 클라이언트에게 알려주기 위해, 요청에 Allow 헤더가 포함되어야 한다. |
| 406 | Not Acceptable | 클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 매해 매개변수로 명시할 수 있다. |
| 407 | Proxy Authentication Required | 401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다. |
| 408 | Request Timeout | 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다. |
| 409 | Conflict | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지정하기 위해 사용한다. |
| 410 | Gone | 404와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다르다. |
| 411 | Length Required | 서버가 요청 메시지에 Content-Length 헤더가 있을 것을 요구할 때 사용한다. |
| 412 | Precondition Failed | 클라이언트가 조건부 요청을 했는데 그중 하나가 실패했을 때 사용한다. 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생한다. |
| 413 | Request Entity Too Large | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용한다. |
| 414 | Request URI Too Long | 서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용한다. |
| 415 | Unsupported Media Type | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 보냈을 때 사용한다. |
| 416 | Requested Range Not Satisfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘못되었거나 맞지 않을 때 사용한다. |
| 417 | Expectation Failed | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용한다. |

### 500-599: 서버 에러 상태 코드

| 상태 코드 | 사유 구절 | 의미 |
|--------|------|------|
| 500 | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다. |
| 501 | Not Implemented | 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다. |
| 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다. |
| 503 | Service Unavailable | 현재는 서버가 요청을 처리해줄 수 없지만 나중에는 가능함을 의미한다. |
| 504 | Gateway Timeout | 상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기라디가 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다. |
| 505 | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다. |

## 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함게 사용된다.

헤더는 크게 다섯 가지로 분류된다.

### 일반 헤더(General Headers)

클라이언트와 서버 모두가 사용한다. 메시지에 대한 아주 기본적인 정보를 제공한다. 메시지가 어떤 종류이든 상관없이 유용한 정보를 제공한다.

예) `Date: Tue, 3 Oct 1974 02:16:00 GMT` → 메시지가 만들어진 일시 지칭

- 일반 정보 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Connection | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다. |
    | Date | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다. |
    | MIME-Version | 발송자가 사용한 MIME의 버전을 알려준다. |
    | Trailer chunked transfer | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열한다. |
    | Transfer-Encoding | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 말해준다. |
    | Upgrade | 발송자가 '업그레이드'하길 원하는 새 버전이나 프로토콜을 알려준다. |
    | Via | 이 메시지가 어떤 중개자(프락시, 게이트웨이)를 거쳐 왔는지 보여준다. |

- 일반 캐시 헤더

    HTTP/1.0은 HTTP 애플리케이션에게 매번 원 서버로부터 객체를 가져오는 대신 로컬 복사본으로 캐시할 수 있도록 해주는 최초의 헤더를 도입했다.

    | 헤더 | 설명 |
    |--------|------|
    | Cache-Control | 메시지와 함께 캐시 지시자를 전달하기 위해 사용한다. |
    | Pragma | 메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않는다. |

### 요청 헤더(Request Headers)

요청 헤더는 요청 메시지를 위한 헤더다.

서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지 등의 부가 정보를 제공한다.

예) `Accept: */*` → 요청에 대응하는 어떤 미디어 타입도 받아들일 것을 의미

- Accept 관련 헤더들

    | 헤더 | 설명 |
    |--------|------|
    | Accept | 서버가 보내도 되는 미디어 종류 |
    | Accept-Charset | 서버가 보내도 되는 문자집합 |
    | Accept-Encoding | 서버가 보내도 되는 인코딩 |
    | Accept-Language | 서버가 보내도 되는 언어 |
    | TE | 서버가 보내도 되는 확장 전송 코딩 |

- 조건부 요청 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Expect | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다. |
    | If-Match | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다. |
    | If-Modified-Since | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다. |
    | If-None-Match | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다. |
    | If-Range | 문서의 특정 범위에 대한 요청을 할 수 있게 해준다. |
    | If-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다. |
    | Range | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다. |

- 요청 보안 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다. |
    | Cookie | 클라이언트가 서버에게 토큰을 전달할 때 사용한다. 진짜 보안 헤더는 아니지만, 보안에 영향을 줄 수 있다는 것은 확실하다. |
    | Cookie2 | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용한다. |

- 프락시 요청 헤더

    | 헤더 | 설명 |
    | Max-Forwards | 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE 메서드와 함께 사용된다. |
    | Proxy-Authorization | Authorizaion과 같으나 프락시에서 인증을 할 때 쓰인다. |
    | Proxy-Connection | Connection과 같으나 프락시에서 연결을 맺을 때 쓰인다. |

### 응답 헤더(Response Headers)

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.

예) `Server: Tiki-Hut/1.0` → 클라이언트에게 Tiki-Hut 서버 1.0 버전과 대화하고 있음을 말해줌

- 응답 정보 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Age | 응답이 얼마나 오래되었는지 |
    | Public | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 |
    | Retry-After | 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시각 |
    | Server | 서버 애플리케이션의 이름과 버전 |
    | Title | HTML 문서에서 주어진 것과 같은 제목 |
    | Warning | 사유 구절에 있는 것보다 더 자세한 경고 메시지 |

- 협상 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태 |
    | Vary | 서버가 확인해 보아야 하고 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록 |

- 응답 보안 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Proxy-Authenticate | 프락시에서 클라이언트로 보낸 인증요구의 목록 |
    | Set-Cookie | 진짜 보안 헤더는 아니지만, 보안에 영향은 줄 수 있다. 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용한다. |
    | Set-Cookie2 | RFC 2965로 정의된 쿠키 |
    | WWW-Authenticate | 서버에서 클라이언트로 보낸 인증요구의 목록 |

### 엔터티 헤더(Entity Headers)

엔터티 헤더란 엔터티 본문에 대한 헤더를 말한다.

예) `Content-Type: text/html; charset=iso-latin-1` → 애플리케이션에게 데이터가 iso-latin-1 문자집합으로 된 HTML 문서임을 알려줌

- 엔터티 정보 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Allow | 이 엔터티에 대해 수행될 수 있는 요청 메서드를 나열한다. |
    | Location | 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해준다. 수신자에게 리소스에 대한 (아마도 새로운) 위치(URL)을 알려줄 때 사용한다. |

- 콘텐츠 헤더

    | 헤더 | 설명 |
    |--------|------|
    | Content-Base | 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL |
    | Content-Encoding | 본문에 적용된 인코딩 |
    | Content-Language | 본문을 이해하는데 가장 적절한 자연어 |
    | Content-Length | 본문의 길이나 크기 |
    | Content-Location | 리소스가 실제로 어디에 위치하는지 |
    | Content-MD5 | 본문의 MD5 체크섬(checksum) |
    | Content-Range | 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현 |
    | Content-Type | 이 본문이 어떤 종류의 객체인지 |

- 엔터티 캐싱 헤더

    | 헤더 | 설명 |
    |--------|------|
    | ETag | 이 엔터티에 대한 엔터티 태그 |
    | Expires | 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
    | Last-Modified | 가장 최근 이 엔터티가 변경된 일시 |

### 확장 헤더(Extension Headers)

확장 헤더는 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더다.