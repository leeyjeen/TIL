# Concurrency

## Share by communicating

동시성 프로그래밍은 큰 주제이며 여기에는 Go만의 특화된 하이라이트를 위한 공간이 있다.

많은 환경에서 동시성 프로그래밍은 공유 변수에 대한 올바른 액세스를 구현하는 데 필요한 세부사항으로 인해 어려워진다. Go는 **공유된 값이 채널에서 전달**되고 실제로 별도의 실행 스레드에 의해 활발히 공유되지 않는 **다른 접근 방식**을 장려한다. 지정된 시간에 하나의 고루틴만 값에 접근할 수 있다. 데이터 경주는 설계상 발생할 수 없다. 이러한 사고 방식을 장려하기 위해 이를 슬로건으로 축소해보았다.

> 메모리를 공유하여 통신하지 마라. 대신, 통신하여 메모리를 공유하라.

이 접근 방식은 도가 지나칠 수 있다. 예를 들어, 참조 횟수는 정수 변수 주위에 뮤텍스를 두는 것이 가장 좋다. 그러나 고급 접근 방식으로서 채널을 사용하여 액세스를 제어하면 명확하고 정확한 프로그램을 쉽게 작성할 수 있다.

이 모델에 대해 생각하는 한 가지 방법은 하나의 CPU에서 실행되는 일반적인 단일 스레드 프로그램을 고려하는 것이다. 이는 동기화 기본 요소가 필요하지 않다. 이제 다른 인스턴스를 실행한다. 이 또한 동기화가 필요 없다. 이제 그 둘이 통신하도록 한다. 통신이 동기화 장치인 경우 다른 동기화가 필요하지 않다. 예를 들어 유닉스 파이프라인은 이 모델에 완벽하게 맞다. 동시성에 대한 Go의 접근 방식은 Hoare의 CSP (Communication Sequential Processes)에서 비롯되었지만 Unix 파이프의 type-safe 일반화로도 볼 수 있다.

## Goroutines

스레드, 코루틴, 프로세스 등의 기존 용어가 부정확한 의미를 전달하기 때문에 goroutine(고루틴)이라고 부른다. 고루틴은 간단한 모델을 갖는다. 동일한 주소 공간에서 다른 고루틴과 동시에 실행되는 함수이다. 이는 경량이며, 스택 공간 할당 비용보다 약간 더 든다. 또한 스택은 소규모로 시작되므로 비용이 적게 들며 필요에 따라 힙 스토리지를 할당(및 해제)하여 확장할 수 있다. 고루틴은 여러 OS 스레드에 멀티플렉싱되므로 I/O를 기다리는 동안처럼 하나가 차단되어야 하는 경우 다른 스레드는 계속 실행된다. 이러한 설계는 스레드 생성 및 관리의 많은 복잡성을 숨긴다.

새로운 고루틴에서 호출을 실행하려면 함수 또는 메서드 호출 앞에 go 키워드를 붙인다. 호출이 완료되면 고루틴이 조용히 종료된다. (이 효과는 백그라운드에서 명령을 실행하기 위한 Unix 셸의 & 표기법과 유사하다.)

```go
go list.Sort()  // run list.Sort concurrently; don't wait for it.
```

함수 리터럴은 고루틴 호출에 유용할 수 있다. 

```go
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
```

Go에서 함수 리터럴은 클로저이다. 구현은 함수가 참조하는 변수가 활성 상태인 동안 지속되도록 보장한다.

이 예시는 함수가 완료 신호를 보낼 방법이 없기 때문에 실용적이지 않다. 이를 위해, channel(채널)이 필요하다. 

## Channels


## Channels of channels


## Parallelization


## A leaky buffer