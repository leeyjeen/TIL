# Clean Architecture
<img src="./images/CleanArchitecture.jpg" width="80%" alt="Insert an element at the end of the queue">
<br><br>

지난 몇 년간 시스템 아키텍처에 관한 모든 범위의 아이디어를 봐왔다. 이는 다음을 포함한다.
* Hexagonal Architecture
* Onion Architecture
* Screaming Architecture
* DCI
* BCE

이러한 아키텍처들은 모두 세부사항에서 다소 차이가 있지만, 매우 유사하다. 그들은 모두 동일한 목표, 즉 관심사 분리를 가지고 있다. 그들은 모두 소프트웨어를 레이어(계층)로 나누어 이러한 분리를 달성한다. 각각에는 비즈니스 규칙을 위한 계층과 인터페이스에 대한 계층을 하나 이상 가지고 있다.

이들 아키텍처 각각은 다음과 같은 시스템을 생성한다.

1. 프레임워크와 독립적이다. 아키텍처는 일부 기능이 포함된 소프트웨어 라이브러리의 존재에 의존하지 않는다. 이를 통해 제한된 제약에 시스템을 밀어 넣을 필요 없이 이러한 프레임워크를 도구로 사용할 수 있다.
2. 테스트가 가능하다. 비즈니스 규칙은 UI, 데이터베이스, 웹 서버 또는 기타 외부 요소 없이 테스트할 수 있다. 
3. UI와 독립적이다. UI는 시스템의 나머지 부분을 변경하지 않고도 쉽게 변경할 수 있다. 예를 들어 비즈니스 규칙을 변경하지 않고 웹 UI를 콘솔 UI로 바꿀 수 있다.
4. 데이터베이스 독립적이다. Oracle 또는 SQL Server, MongoDB, CouchDB 등 다른 것으로 교체할 수 있다. 비즈니스 규칙은 데이터베이스에 바인딩되지 않는다.
5. 외부 기관과 독립적이다. 실제로 비즈니스 규칙은 외부 세계에 대해 전혀 알지 못한다.

맨 위에 있는 다이어그램은 이러한 모든 아키텍처를 하나의 실행 가능한 아이디어로 통합하려는 시도이다.

# The Dependency Rule | 종속성 규칙
동심원은 소프트웨어의 여러 영역을 나타낸다. 일반적으로 내부로 갈수록 고수준의 소프트웨어이다. 바깥 쪽 원은 메커니즘이다. 내부 원은 정책이다.

이 아키텍처가 작동하도록 만드는 우선 규칙은 Dependency Rule(종속성 규칙)이다. 이 규칙은 소스 코드 종속성이 내부로만 향할 수 있다고 말한다. 내부 원의 어떤 것도 외부 원의 어떤 것에 대해 전혀 알 수 없다. 특히 외부 원에 선언된 이름은 내부 원에 있는 코드에서 언급되지 않아야 한다. 여기에는 함수, 클래스, 변수 또는 기타 명명된 소프트웨어 개체가 포함된다.

마찬가지로, 외부 원에서 사용되는 데이터 형식은 특히 외부 원의 프레임워크에 의해 생성되는 경우 내부 원에서 사용해서는 안된다. 바깥 쪽 원 안에 있는 어떤 것도 안쪽 원에 영향을 주는 것을 원하지 않는다.

# Entities
엔티티는 전사적 비즈니스 규칙을 캡슐화한다. 엔티티는 메소드가 있는 객체이거나 데이터 구조 및 함수의 집합일 수 있다.

단일 애플리케이션을 작성하는 경우 이러한 엔티티는 애플리케이션의 비즈니스 객체이다. 가장 일반적이고 높은 수준의 규칙을 캡슐화한다. 외부가 변경될 때 변경될 가능성이 가장 적다. 예를 들어 페이지 탐색 또는 보안 변경으로 인해 이러한 개체가 영향을받지 않을 것으로 예상한다. 특정 애플리케이션에 대한 운영 변경은 엔티티 계층에 영향을 주지 않아야한다.

# Use Cases
이 계층의 소프트웨어에는 애플리케이션별 비즈니스 규칙이 포함된다. 시스템의 모든 사용 사례를 캡슐화하고 구현한다. 이러한 사용 사례는 엔티티와의 데이터 흐름을 조율하고 해당 엔티티가 사용 사례의 목표를 달성하기 위해 전사적 비즈니스 규칙을 사용하도록 지시한다.

이 레이어의 변경 사항이 엔티티에 영향을 미치지 않을 것으로 예상한다. 또한 이 레이어가 데이터베이스, UI 또는 공통 프레임워크와 같은 외부 요소의 변경에 의해 영향을 받지 않을 것으로 예상한다. 이 레이어는 이러한 관심사에서 분리된다.

그러나 응용 프로그램의 작동에 대한 변경이 사용 사례 및 이 레이어의 소프트웨어에 영향을 미칠 것으로 예상한다. 사용 사례의 세부 사항이 변경되면서 이 레이어의 일부 코드가 확실히 영향을 받는다.

# Interface Adapters
이 계층의 소프트웨어는 사용 사례 및 엔티티에 가장 편리한 형식에서 데이터베이스 또는 웹과 같은 일부 외부 기관에 가장 편리한 형식으로 데이터를 변환하는 어댑터 세트이다. 예를 들어 GUI의 MVC 아키텍처를 완전히 포함하는 것은 이 계층이다. 프리젠터, 뷰 및 컨트롤러가 모두 여기에 속한다. 모델은 컨트롤러에서 사용 사례로 전달된 다음 사용 사례에서 프리젠터 및 뷰로 다시 전달되는 데이터 구조일 가능성이 높다.

마찬가지로 데이터는 이 계층에서 엔티티 및 사용 사례에 가장 편리한 형식에서 사용중인 지속성 프레임워크에 가장 편리한 형식으로 변환된다. 즉, 데이터베이스. 이 원 내부의 코드는 데이터베이스에 대해 전혀 알지 못한다. 데이터베이스가 SQL 데이터베이스인 경우 모든 SQL은 이 계층, 특히 데이터베이스와 관련된 이 계층의 일부로 제한되어야 한다.

또한 이 계층에는 외부 서비스와 같은 일부 외부 형식의 데이터를 사용 사례 및 엔티티에서 사용하는 내부 형식으로 변환하는 데 필요한 다른 어댑터가 있다.

# Frameworks and Drivers
가장 바깥쪽 레이어는 일반적으로 데이터베이스, 웹 프레임워크 등과 같은 프레임워크와 툴로 구성된다. 일반적으로 이 레이어에는 안쪽으로 다음 원과 통신하는 글루 코드 외에 많은 코드를 작성하지 않는다.

이 레이어는 모든 세부 사항이 있는 곳이다. 웹은 세부 사항이다. 데이터베이스는 세부 사항이다. 우리는 이러한 것들을 거의 해를 끼치지 않는 외부에 보관한다.

# Only Four Circles?
아니다, 원은 도식이다. 이 네 가지 이상이 필요하다는 것을 알 수 있다. 항상 이 네 가지만 가져야 한다는 규칙은 없다. 그러나 종속성 규칙은 항상 적용된다. 소스 코드 종속성은 항상 안쪽을 가리킨다. 안쪽으로 이동하면 추상화 수준이 높아진다. 가장 바깥쪽 원은 낮은 수준의 구체적인 세부 사항이다. 내부로 이동함에 따라 소프트웨어는 더욱 추상적이고 더 높은 수준의 정책을 캡슐화한다. 가장 안쪽의 원이 가장 일반적이다.

# Crossing boundaries
다이어그램의 오른쪽 하단에는 우리가 원 경계를 어떻게 교차하는지 보여주는 예가 있다. 컨트롤러와 프리젠터가 다음 레이어에서 어떻게 사용 사례와 통신하는지 보여준다. 제어 흐름에 유의하여야 한다. 컨트롤러에서 시작하여 사용 사례를 살펴본 다음 프리젠터에서 실행된다. 소스 코드 종속성도 확인해보면, 그들 각각은 사용 사례를 향해 안쪽을 가르킨다.

일반적으로 종속성 반전 원칙을 사용하여 이 명백한 모순을 해결한다. 예를 들어 Java와 같은 언어에서는 소스 코드 종속성이 경계를 가로질러 올바른 지점에서 제어 흐름에 반대하도록 인터페이스 및 상속 관계를 배열한다.

예를 들어 사용 사례가 프리젠터를 호출할 필요가 있다고 생각해보자. 그러나, 이 호출은 종속성 규칙에 따라 외부 원의 이름을 내부 원에서 언급될 수 없기 때문에 직접적일 수 없다. 그래서 우리는 내부 원에서 인터페이스(여기서는 사용 사례 출력 포트로 표시됨)를 호출하고 외부 원의 프리젠터가 이를 구현하도록 한다.

동일한 기술을 사용하여 아키텍처의 모든 경계를 넘는다. 동적 다형성을 이용하여 제어 흐름에 반대되는 소스 코드 종속성을 생성하여 제어 흐름이 어떤 방향으로 들어 가든 종속성 규칙을 준수할 수 있다.

# What data crosses the boundaries
일반적으로 경계를 넘는 데이터는 단순한 데이터 구조이다. 원하는 경우 기본 구조체 또는 간단한 데이터 전송 객체를 사용할 수 있다. 또는 데이터는 단순히 함수 호출의 인수가 될 수 있다. 또는 해시 맵으로 압축하거나 객체로 구성할 수 있다. 중요한 것은 격리되고 단순한 데이터 구조가 경계를 넘어 전달된다는 것이다. 우리는 엔티티 또는 데이터베이스 행을 속이고 전달하고 싶지 않다. 데이터 구조에 종속성 규칙을 위반하는 종속성이 포함되는 것을 원하지 않는다. 

예를 들어, 많은 데이터베이스 프레임워크는 쿼리에 대한 응답으로 편리한 데이터 형식을 반환한다. 이것을 RowStructure라고 부를 수 있다. 이 행 구조를 경계를 넘어 안쪽으로 전달하고 싶지 않다. 그것은 내부 원이 외부 원에 대해 무언가를 알도록 강요하기 때문에 종속성 규칙을 위반한다.

따라서 경계를 넘어 데이터를 전달할 때 항상 내부 원에 가장 편리한 형식이 된다.

# Conclusion
이러한 간단한 규칙을 준수하는 것은 어렵지 않으며 앞으로 많은 두통을 덜어줄 것이다. 소프트웨어를 계층으로 분리하고 종속성 규칙을 준수하면 모든 이점이 포함된 본질적으로 테스트 가능한 시스템을 만들 수 있다. 데이터베이스 또는 웹 프레임워크와 같이 시스템의 외부 부분이 사용되지 않는 경우 이러한 사용되지 않는 요소를 최소한의 번거로움으로 바꿀 수 있다.

# Review
## 소프트웨어의 가장 중요한 가치는 쉽게 변화할 수 있는 성질이다
소프트웨어 설계, 좋은 아키텍처가 필요한 이유는 소프트웨어의 본질은 변하는 것이기 때문이다.

요구사항은 시시각각 변한다. 새로운 기능을 개발해야 할 수도, 이미 있는 기능을 바꿔야 할 수도 있다. 

따라서, 소프트웨어가 현재의 요구사항을 정확히 만족하도록 개발하는 것도 중요하지만, 더 중요한 것은 소프트웨어가 쉽게 변화할 수 있도록 만드는 것이다. 적절히 코드를 나누고, 적절한 위치에 적절한 책임을 두고, 나뉘어진 코드끼리 적절한 의존성을 가지게 하여야 한다.

또한, 좋은 아키텍처는 선택을 미룰 수 있는 아키텍처이다. 요구사항은 항상 불완전하여, 아직 결정되지 않은 사항이 많다. 이러한 사항들에 대해 선택을 미리 하면 나중에 요구사항이 바뀌었을 때 더 큰 비용을 지불해야 한다. 따라서 현재 결정하지 않아도 되는 사항, 이를테면 기술 스택이나 불분명한 요구사항을 불분명한 채로 놔두고, 나중에 선택을 했을 때 이를 쉽게 반영할 수 있도록 아키텍처를 설계해야 한다.

## 쉽게 변화하는 소프트웨어를 만드는 방법
소프트웨어는 필연적으로 변한다. 소프트웨어가 쉽게 변화할 수 있기 위해서는, 1. 바꾸어야 할 부분을 쉽고 명확하게 파악할 수 있어야 하고, 2. 변경이 최소한으로 일어나야 한다. 

의존 관계에 있는 컴포넌트 사이에는 변화가 전파된다. A->B로의 의존성이 있는 경우, B가 변화하면 A도 반드시 변화하여야 한다. 

변경을 최소화할 수 있는 방법은
1. 변경이 함께 일어나는 컴포넌트끼리 한 데 묶고 (SRP - Single Responsibility Principle)
2. 자주 바뀌는 컴포넌트에서 상대적으로 자주 바뀌지 않는 컴포넌트 방향으로의 의존성만 있도록 (DIP - Dependency Inversion Principle) 의존성을 관리하는 것이다.

## 테스트의 가치
소프트웨어의 본질을 변하는 것으로 생각할 때 테스트는 한 가지 중요한 가치를 더 가지게 된다. 테스트는 소프트웨어를 마음 편히 변경할 수 있는 안전장치로 작용한다. 변경사항에 대응하여 다시 설계하고 거듭 리팩토링을 해나가는 과정에서, 소프트웨어가 기존 요구사항을 여전히 잘 수행하는지를 매우 손쉽게 판단할 수 있는 수단이 바로 자동화된 테스트이다. 

테스트는 구현 방식과는 독립적으로 기능의 명세를 테스트해야 한다. 소프트웨어의 내부 구현이 바뀌더라도 변경될 필요가 없는 동시에 명세대로 잘 동작하는지를 확인할 수 있는 적절한 수준의 테스트를 작성해야 한다.

## 정리
"소프트웨어의 가장 중요한 가치는 쉽게 변경할 수 있는 성질"이라는 사고방식으로 설계함으로써 깔끔하고 유연한 설계가 가능해졌다.

## 기타
(상대적으로 엔티티가 고수준, 유스케이스가 저수준이다) "왜냐하면 유스케이스는 단일 애플리케이션에 특화되어 있으며,
따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문이다."

"유스케이스는 단순한 요청 데이터 구조를 입력으로 받아들이고, 단순한 응답 데이터 구조를 출력으로 반환한다. 이들 데이터 구조는 어떤 것에도 의존하지 않는다."

"이 경험은 데이터베이스는 세부사항이며, 시스템의 전반적인 업무목적과는 반드시 분리해야 한다는 원칙을 배울 수 있었던 여러 경험 중 하나였다." 371P

## 장점
이 아키텍처의 가장 큰 장점은 확장이 쉽다는 것이다. 이것이 Clean Architecture의 기둥 중 하나이기 때문에 그리 놀라운 일은 아니다. 

또한 응용 프로그램이 잘 구분된다. 이를 통해 한 번에 하나의 문제에 집중할 수 있다. 또한 시스템의 한 부분에만 집중하기 때문에 컴포넌트를 작게 유지해야 한다. 작은 컴포넌트는 추론하기 쉽다. 당면한 문제에 대한 좋은 해결책을 찾는 데 도움이 된다.

잘 나눠진 프로젝트인 덕분에 어떤 역할을 하는 코드가 어디에 있는지 명확하게 파악 가능하다. 

## 단점
데이터 구조를 변경할 때, test와 repository 등과 같이 변경되어야 하는 곳이 발생한다. 예상되지 않으나 다른 코드에서 많은 변경사항이 발생한다. 이것은 이 실험이 나를 더 잘 알게 했기 때문이거나 아키텍처가 이것을 강조했기 때문일 수 있다. 돌이켜보면 그렇게 큰 단점은 아니지만 아키텍처가 이러한 것들을 어떻게 조명하는지에 대한 관찰이다.

Clean Architecture에 대한 일반적인 관찰은 이 아키텍처가 소규모 프로젝트에 과도하다는 것이다. 많은 장점을 제공하지만 이러한 장점을 얻으려면 많은 노력을 기울여야 한다. 

모든 인터페이스와 분리된 프로젝트가 없으면 훨씬 더 빠르게 작업을 수행할 수 있다. 그러나 그것은 확장성이 훨씬 적다는 것을 의미한다. 나중에 필요할 때 확장성을 추가할 수 있다. 예를 들어 데이터 소스를 추가해야 할 때 IWorkRepository 인터페이스를 배치할 수 있다. 항상 YAGNI 사이의 push, pull이며 나중에 설계 변경을 어렵게 만드는 유연성이 부족하다. 추가된 인터페이스와 확장 포인트는 최종 결과에 도움이 되는 코드의 일부를 어떻게 처리할지 두 번 생각하게 만든다. 

파일 수가 많아지는 점이 있다. 그와 반비례적으로 한 클래스당 라인 수가 줄어들어 가독성이 향상된다.

아키텍처에 대한 이해도 없이 처음 보는 경우 코드를 따라가며 이해하는 게 힘들고 한번에 구조를 잘 잡기는 어렵다.

급한 상황에서는 신경쓰기 힘들다.

## Reference
* https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
* https://suhwan.dev/2019/10/06/review-clean-architecture/
* https://kenbonny.net/2019/04/15/clean-architecture-applied-review/
* https://woowabros.github.io/experience/2019/01/17/baeminapp-clean-architecture.html