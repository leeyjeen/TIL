# Clean Architecture
<img src="./images/CleanArchitecture.jpg" width="80%" alt="Insert an element at the end of the queue">
<br><br>

지난 몇 년간 시스템 아키텍처에 관한 모든 범위의 아이디어를 봐왔다. 이는 다음을 포함한다.
* Hexagonal Architecture
* Onion Architecture
* Screaming Architecture
* DCI
* BCE

이러한 아키텍처들은 모두 세부사항에서 다소 차이가 있지만, 매우 유사하다. 그들은 모두 동일한 목표, 즉 관심사 분리를 가지고 있다. 그들은 모두 소프트웨어를 레이어(계층)로 나누어 이러한 분리를 달성한다. 각각에는 비즈니스 규칙을 위한 계층과 인터페이스에 대한 계층을 하나 이상 가지고 있다.

이들 아키텍처 각각은 다음과 같은 시스템을 생성한다.

1. 프레임워크와 독립적이다. 아키텍처는 일부 기능이 포함된 소프트웨어 라이브러리의 존재에 의존하지 않는다. 이를 통해 제한된 제약에 시스템을 밀어 넣을 필요 없이 이러한 프레임워크를 도구로 사용할 수 있다.
2. 테스트가 가능하다. 비즈니스 규칙은 UI, 데이터베이스, 웹 서버 또는 기타 외부 요소 없이 테스트할 수 있다. 
3. UI와 독립적이다. UI는 시스템의 나머지 부분을 변경하지 않고도 쉽게 변경할 수 있다. 예를 들어 비즈니스 규칙을 변경하지 않고 웹 UI를 콘솔 UI로 바꿀 수 있다.
4. 데이터베이스 독립적이다. Oracle 또는 SQL Server, MongoDB, CouchDB 등 다른 것으로 교체할 수 있다. 비즈니스 규칙은 데이터베이스에 바인딩되지 않는다.
5. 외부 기관과 독립적이다. 실제로 비즈니스 규칙은 외부 세계에 대해 전혀 알지 못한다.

맨 위에 있는 다이어그램은 이러한 모든 아키텍처를 하나의 실행 가능한 아이디어로 통합하려는 시도이다.

# The Dependency Rule | 종속성 규칙
동심원은 소프트웨어의 여러 영역을 나타낸다. 일반적으로 내부로 갈수록 고수준의 소프트웨어이다. 바깥 쪽 원은 메커니즘이다. 내부 원은 정책이다.

이 아키텍처가 작동하도록 만드는 우선 규칙은 Dependency Rule(종속성 규칙)이다. 이 규칙은 소스 코드 종속성이 내부로만 향할 수 있다고 말한다. 내부 원의 어떤 것도 외부 원의 어떤 것에 대해 전혀 알 수 없다. 특히 외부 원에 선언된 이름은 내부 원에 있는 코드에서 언급되지 않아야 한다. 여기에는 함수, 클래스, 변수 또는 기타 명명된 소프트웨어 개체가 포함된다.

마찬가지로, 외부 원에서 사용되는 데이터 형식은 특히 외부 원의 프레임워크에 의해 생성되는 경우 내부 원에서 사용해서는 안된다. 바깥 쪽 원 안에 있는 어떤 것도 안쪽 원에 영향을 주는 것을 원하지 않는다.

# Entities
엔티티는 전사적 비즈니스 규칙을 캡슐화한다. 엔티티는 메소드가 있는 객체이거나 데이터 구조 및 함수의 집합일 수 있다.

단일 애플리케이션을 작성하는 경우 이러한 엔티티는 애플리케이션의 비즈니스 객체이다. 가장 일반적이고 높은 수준의 규칙을 캡슐화한다. 외부가 변경될 때 변경될 가능성이 가장 적다. 예를 들어 페이지 탐색 또는 보안 변경으로 인해 이러한 개체가 영향을받지 않을 것으로 예상한다. 특정 애플리케이션에 대한 운영 변경은 엔티티 계층에 영향을 주지 않아야한다.

# Use Cases
이 계층의 소프트웨어에는 애플리케이션별 비즈니스 규칙이 포함된다. 시스템의 모든 사용 사례를 캡슐화하고 구현한다. 이러한 사용 사례는 엔티티와의 데이터 흐름을 조율하고 해당 엔티티가 사용 사례의 목표를 달성하기 위해 전사적 비즈니스 규칙을 사용하도록 지시한다.

이 레이어의 변경 사항이 엔티티에 영향을 미치지 않을 것으로 예상한다. 또한 이 레이어가 데이터베이스, UI 또는 공통 프레임워크와 같은 외부 요소의 변경에 의해 영향을 받지 않을 것으로 예상한다. 이 레이어는 이러한 관심사에서 분리된다.

그러나 응용 프로그램의 작동에 대한 변경이 사용 사례 및 이 레이어의 소프트웨어에 영향을 미칠 것으로 예상한다. 사용 사례의 세부 사항이 변경되면서 이 레이어의 일부 코드가 확실히 영향을 받는다.

# Interface Adapters
이 계층의 소프트웨어는 사용 사례 및 엔티티에 가장 편리한 형식에서 데이터베이스 또는 웹과 같은 일부 외부 기관에 가장 편리한 형식으로 데이터를 변환하는 어댑터 세트이다. 예를 들어 GUI의 MVC 아키텍처를 완전히 포함하는 것은 이 계층이다. 프리젠터, 뷰 및 컨트롤러가 모두 여기에 속한다. 모델은 컨트롤러에서 사용 사례로 전달된 다음 사용 사례에서 프리젠터 및 뷰로 다시 전달되는 데이터 구조일 가능성이 높다.

마찬가지로 데이터는 이 계층에서 엔티티 및 사용 사례에 가장 편리한 형식에서 사용중인 지속성 프레임워크에 가장 편리한 형식으로 변환된다. 즉, 데이터베이스. 이 원 내부의 코드는 데이터베이스에 대해 전혀 알지 못한다. 데이터베이스가 SQL 데이터베이스인 경우 모든 SQL은 이 계층, 특히 데이터베이스와 관련된 이 계층의 일부로 제한되어야 한다.

또한 이 계층에는 외부 서비스와 같은 일부 외부 형식의 데이터를 사용 사례 및 엔티티에서 사용하는 내부 형식으로 변환하는 데 필요한 다른 어댑터가 있다.

# Frameworks and Drivers
가장 바깥쪽 레이어는 일반적으로 데이터베이스, 웹 프레임워크 등과 같은 프레임워크와 툴로 구성된다. 일반적으로 이 레이어에는 안쪽으로 다음 원과 통신하는 글루 코드 외에 많은 코드를 작성하지 않는다.

이 레이어는 모든 세부 사항이 있는 곳이다. 웹은 세부 사항이다. 데이터베이스는 세부 사항이다. 우리는 이러한 것들을 거의 해를 끼치지 않는 외부에 보관한다.

# Only Four Circles?
아니다, 원은 도식이다. 이 네 가지 이상이 필요하다는 것을 알 수 있다. 항상 이 네 가지만 가져야 한다는 규칙은 없다. 그러나 종속성 규칙은 항상 적용된다. 소스 코드 종속성은 항상 안쪽을 가리킨다. 안쪽으로 이동하면 추상화 수준이 높아진다. 가장 바깥쪽 원은 낮은 수준의 구체적인 세부 사항이다. 내부로 이동함에 따라 소프트웨어는 더욱 추상적이고 더 높은 수준의 정책을 캡슐화한다. 가장 안쪽의 원이 가장 일반적이다.

# Crossing boundaries
다이어그램의 오른쪽 하단에는 우리가 원 경계를 어떻게 교차하는지 보여주는 예가 있다. 컨트롤러와 프리젠터가 다음 레이어에서 어떻게 사용 사례와 통신하는지 보여준다. 제어 흐름에 유의하여야 한다. 컨트롤러에서 시작하여 사용 사례를 살펴본 다음 프리젠터에서 실행된다. 소스 코드 종속성도 확인해보면, 그들 각각은 사용 사례를 향해 안쪽을 가르킨다.

일반적으로 종속성 반전 원칙을 사용하여 이 명백한 모순을 해결한다. 예를 들어 Java와 같은 언어에서는 소스 코드 종속성이 경계를 가로질러 올바른 지점에서 제어 흐름에 반대하도록 인터페이스 및 상속 관계를 배열한다.

예를 들어 사용 사례가 프리젠터를 호출할 필요가 있다고 생각해보자. 그러나, 이 호출은 종속성 규칙에 따라 외부 원의 이름을 내부 원에서 언급될 수 없기 때문에 직접적일 수 없다. 그래서 우리는 내부 원에서 인터페이스(여기서는 사용 사례 출력 포트로 표시됨)를 호출하고 외부 원의 프리젠터가 이를 구현하도록 한다.

동일한 기술을 사용하여 아키텍처의 모든 경계를 넘는다. 동적 다형성을 이용하여 제어 흐름에 반대되는 소스 코드 종속성을 생성하여 제어 흐름이 어떤 방향으로 들어 가든 종속성 규칙을 준수할 수 있다.

# What data crosses the boundaries
일반적으로 경계를 넘는 데이터는 단순한 데이터 구조이다. 원하는 경우 기본 구조체 또는 간단한 데이터 전송 객체를 사용할 수 있다. 또는 데이터는 단순히 함수 호출의 인수가 될 수 있다. 또는 해시 맵으로 압축하거나 객체로 구성할 수 있다. 중요한 것은 격리되고 단순한 데이터 구조가 경계를 넘어 전달된다는 것이다. 우리는 엔티티 또는 데이터베이스 행을 속이고 전달하고 싶지 않다. 데이터 구조에 종속성 규칙을 위반하는 종속성이 포함되는 것을 원하지 않는다. 

예를 들어, 많은 데이터베이스 프레임워크는 쿼리에 대한 응답으로 편리한 데이터 형식을 반환한다. 이것을 RowStructure라고 부를 수 있다. 이 행 구조를 경계를 넘어 안쪽으로 전달하고 싶지 않다. 그것은 내부 원이 외부 원에 대해 무언가를 알도록 강요하기 때문에 종속성 규칙을 위반한다.

따라서 경계를 넘어 데이터를 전달할 때 항상 내부 원에 가장 편리한 형식이 된다.

# Conclusion
이러한 간단한 규칙을 준수하는 것은 어렵지 않으며 앞으로 많은 두통을 덜어줄 것이다. 소프트웨어를 계층으로 분리하고 종속성 규칙을 준수하면 모든 이점이 포함된 본질적으로 테스트 가능한 시스템을 만들 수 있다. 데이터베이스 또는 웹 프레임워크와 같이 시스템의 외부 부분이 사용되지 않는 경우 이러한 사용되지 않는 요소를 최소한의 번거로움으로 바꿀 수 있다.

## Reference
* https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html